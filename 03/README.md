# AOC 2025 Day 03 - P2 Greedy 方案说明

本文详细说明 P2 中使用的 Greedy（贪心）算法思路，并提供如何在之后的类似问题中识别并应用 Greedy 的方法论。

## 问题背景

- 输入是一行由数字字符组成的序列（`b.batteries`）。
- 目标是在保持原有顺序的前提下，选出长度恰好为 12 的子序列，使得这个 12 位数在数值上最大。
- P1 寻找最大两位数；P2 则是最大 12 位数（本质相同，只是长度不同）。

这类问题可以被表述为：“在一个数字序列中，选择固定长度 L 的有序子序列，使所得数值（字典序/数值）最大”。

## Greedy 的核心思路

对于要选出的第 k 位（从 0 到 L-1）：
- 我们在当前可选区间 `[start, end)` 内选择最大数字。
- 其中 `end = n - (L - k - 1)`，确保选中该位后，尾部仍有足够的元素可以选满剩余的 `L-k-1` 位。
- 选中后将 `start` 更新为该选择位置的下一个索引，继续选下一位。

换言之：每一步都在可行窗口内选择“当前能选到的最大数字”，从而得到字典序最大的子序列。因为数值比较的优先级是从高位到低位，这种逐位最大化就是全局最优。

## 正确性直觉（交换论证）

- 假设第 k 位你没有选到可选窗口内的最大数字，而是选了更小的 `d`。那么将这位替换为更大的 `d'`（且仍在窗口内、后续仍可选足够长度），得到的数在第 k 位就更大，从而整个数更大。
- 因为后续位数只在更低位，无法抵消高位的劣势，所以局部最优（每一步选当前最大）能组成全局最优。

因此，逐位最大化在此语义下是一个可证的 Greedy 策略。

## 复杂度

- 时间复杂度：O(n * L)。每一位在一个收缩的窗口内扫描一次。
- 空间复杂度：O(1)。仅维护位置和累积结果。

## 代码示意（与项目中 `pickGreedy` 一致的核心逻辑）

```/dev/null/README_example.go#L1-50
package main

func pickGreedy(batteries []byte) int {
	n := len(batteries)
	const L = 12
	if n < L {
		return 0
	}
	res := 0
	start := 0
	for k := 0; k < L; k++ {
		end := n - (L - k - 1) // 搜索边界，保证可完成剩余位数
		bestDigit := byte('0' - 1)
		bestPos := start
		for i := start; i < end; i++ {
			d := batteries[i]
			if d > bestDigit {
				bestDigit = d
				bestPos = i
				if bestDigit == '9' {
					break // 最优上界
				}
			}
		}
		res = res*10 + int(bestDigit-'0')
		start = bestPos + 1
	}
	return res
}
```

注意：上述示例仅展示算法核心，与项目中的函数签名略有不同。项目中你已将其封装为 `bank.pickGreedy()` 并把结果记录到 `b.max`。

## 与递归/回溯的对比

- 原始的递归方案（`pick`）尝试所有保序子序列，并用一些剪枝去掉不可能更优的分支，复杂度指数级。
- Greedy 则基于问题结构直接构造最优解，复杂度降至 O(n * L)，对大规模输入更友好。

## 何时应该想到 Greedy？

可以用以下思考路径判断是否适用贪心：

1. 比较目标是否“从左到右优先级下降”（如字典序比较）：高位的选择比低位更重要，局部最优往往能带来全局最优。
2. 是否可以给每一步定义“可行窗口”：在第 k 步，是否存在一个明确的索引范围，保证从该范围选一个元素后仍然能完成剩余长度。
3. 局部替换是否总能改进（交换论证）：若当前选择不是该窗口内最大值，将其替换为最大值是否不会破坏后续可行性，并严格提升目标值。
4. 目标是否是“最大/最小有序子序列”的典型形式：如最大子序列、单调栈相关问题、移除 k 个字符得到最大数等。
5. 无需跨步依赖或全局约束耦合：每一步的选择不依赖后续具体值，只依赖剩余可选数量边界。

如果上述条件成立或高度吻合，基本可以考虑 Greedy。

## 常见陷阱与校验

- 边界计算错误：`end = n - (L - k - 1)` 是确保后续还能选满的关键，容易写错。建议画图或举例来验证。
- 输入包含非数字字符时，需要预处理（本题为数字字符，安全）。
- 目标长度 L 大于输入长度时，应返回约定的结果（此处返回 0）。
- 字符比较与数值累积：注意字符 `'0'..'9'` 与数值 `0..9` 的转换。
- 题目是否允许前导零：本题允许，因为只是最大数值比较，零也可能在最优序列中作为合法位。

## 与经典问题的关系

- 与“从数字字符串中删去 k 个字符使结果最大”的问题类似（常用单调栈或贪心），本题是其变体：固定选取 L 个字符，且必须保持顺序。
- 与“字典序最大子序列”问题等价；贪心窗口选择是常见且标准的解法。

## 总结

- P2 是一个“固定长度、保序、最大数值（字典序最大）子序列”的典型 Greedy 场景。
- 关键在于：
  - 逐位选择当前可行窗口内的最大数字；
  - 正确计算窗口终点以保证后续可完成；
  - 用交换论证保证贪心正确性。
- 相比回溯，Greedy 更快更稳定，适合大输入。

当你在之后遇到类似“保序选取、按高位优先比较”的最大化问题时，优先考虑上述贪心框架，并通过窗口边界与替换论证来确认其适用性。